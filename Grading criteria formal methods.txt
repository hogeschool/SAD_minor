***INTRODUCTION***

An acceptable project for the formal methods aspect of the SAD minor covers the design of a programming language or comparable formalism with clearly specified useful properties.


**Project requirements**

The properties of interest for the minor are:
* security aspects; for example, build a programming language which type system makes it impossible to send classified data without encryption over a network
* safety aspects; for example, build a programming language which type system makes it impossible to duplicate a unique value
* performance aspects; for example, build a programming language which uses code-generation to speed up some decisions by making them compile-time instead of run-time.


**Scope of the project**

An important word of warning concerns the use of tools and languages. It is, in theory, possible to build your own system from scratch, using a programming language made for other tasks (such as Java or C/C++). It is the teacher's estimation that doing so will almost always result in your failure, which for a whole minor has dire consequences. The reason why this will happen is simple. A project such as the ones described above has roughly the following structure:


+---------------+-----------------------+
| TESTING	|	SAMPLES		|
+---------------+-----------------------+
| 		|	CODE-GEN	|
| BACK-END	|	OPTIMIZER*	|
|	 	| 	ANALYZER*	|
+---------------+-----------------------+
| FRONT-END	|	PARSER		|
|		|	LEXER		|
+---------------+-----------------------+


THE ONLY PARTS GRADED DURING THE SAD MINOR ARE THE ONES MARKED WITH AN ASTERISK, that is the _analyzer_ and the _optimizer_ of the language. Everything else is not graded. The reason is simple: grading all of it would quickly put us out of scope and require way too much work on your behalf. Building a reliable front-end is a lot of work. In addition, building a well-working, reliable code generator that outputs useable code is a daunting task. Finally, whatever you choose to do, you will need to provide a series of basic samples that show that all aspects of your language work correctly. 


**Allowed tools and languages**

TO SHIELD YOU FROM ALL THIS WORK, which would be significantly more than a single minor, we provide you with a ready-made meta-compiler that allows the definition of programming languages by focusing directly on the analyzer and the optimizer. The meta-compiler comes equipped with an extensive suite of tests that will help you understand if you broke something, and also how the program works.

You are very strongly encouraged to make use of the meta-compiler because you will get more done, and you will also get more help as the teachers are very expert in it. A list of possible tasks is online in the *issues* section of the meta-compiler GitHub page. 
Should you be interested in actually doing something within the meta-compiler itself, then it is also possible. The meta-compiler is written in F#, and therefore you may add features to it in the same language.

You may also suggest your own project (which should still be inspired from the existing open issues). In this case, use of F# is a strict requirement, and previous acceptance from the teacher is required.


**Conclusions**

To sum this up:
* If you are looking for a relatively easy task, then learn to use the meta-compiler and build your project in it
* If you are looking for a challenging task, then learn to use both the meta-compiler and F#, and make a change to the meta-compiler itself
* If you are looking for a learning experience through almost certain failure, then build the whole structure of your system in F# from scratch


