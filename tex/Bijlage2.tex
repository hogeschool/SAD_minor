\section*{Formal methods project - guidelines}
	An acceptable project for the formal methods aspect of the SAD minor covers the design of a programming language or comparable formalism with clearly specified useful properties.

	The properties of interest for the minor include, but are not limited to:
		\begin{itemize}
			\item security aspects; for example, build a programming language which type system makes it impossible to send classified data without encryption over a network
			\item safety aspects; for example, build a programming language which type system makes it impossible to duplicate a unique value
			\item performance aspects; for example, build a programming language which uses code-generation to speed up some decisions by making them compile-time instead of run-time.
		\end{itemize}
		
	For a longer list of proposals, see \url{https://github.com/vs-team/metacompiler/issues/}. You may add your own proposal.

	\subsection*{Structure of a programming language}
		An important word of warning concerns the use of tools and languages. It is, in theory, possible to build your own system from scratch, using a programming language made for other tasks (such as Java or C/C++). It is the teacher's estimation that doing so will almost always result in your failure, which for a whole minor has dire consequences. The reason why this will happen is simple. A project such as the ones described above has (very roughly) the following structure: \\

		\begin{tabular}{| c | p{5cm} |}
			\hline
			TESTING & SAMPLES* \\
			\hline
			BACKEND & 	\begin{itemize}
							\item CODE-GEN
							\item OPTIMIZER*
							\item ANALYZER*
						\end{itemize} \\
			\hline
			FRONTEND & 	\begin{itemize}
							\item PARSER
							\item LEXER
						\end{itemize} \\
			\hline
		\end{tabular} \\


		\textbf{The only parts relevant and graded during the minor are those marked with an asterisk}, that is the \textit{analyzer} and the \textit{optimizer} of the language. These are the parts where ``real intelligence'' can be put into a programming language, through knowledge of formal systems. Everything else is irrelevant for formal systems, and therefore not graded. The reason is simple: grading all of it would quickly put us out of scope and require way too much work on your behalf. Building a reliable front-end is a lot of work. In addition, building a well-working, reliable code generator that outputs useable code is a daunting task. Finally, whatever you choose to do, you will need to provide a series of basic samples that show that all aspects of your language work correctly. 


	\subsection*{Allowed tools and languages}
		To shield you all from this work, which would be significantly more than a single minor, we provide you with a ready-made meta-compiler that allows the definition of programming languages by focusing directly on the analyzer and the optimizer. The meta-compiler comes equipped with an extensive suite of tests that will help you understand if you broke something, and also how the program works.

		You are very strongly encouraged to make use of the meta-compiler because you will get more done, and you will also get more help as the teachers are very expert in it. The meta-compiler is accessible as a GitHub project at \url{https://github.com/vs-team/metacompiler}.
		
		Should you be interested in actually doing something within the meta-compiler itself, then it is also possible. The meta-compiler is written in F\#, and therefore you may add features to it in the same language.

		You may also suggest your own project (which should still be inspired from the existing open issues). In this case, use of F\# is a still a strict requirement, and previous acceptance from the teacher is required.

	\subsection*{To sum it up}
		If you are looking for a relatively easy task, then learn to use the meta-compiler and build your project in it. If you are looking for a challenging task, then learn to use both the meta-compiler and F\#, and build a feature in the meta-compiler itself. If you are looking for a learning experience through very likely failure, then build the whole structure of your system in F\# from scratch.
